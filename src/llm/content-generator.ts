/**
 * Unified Content Generator
 * 
 * Routes content generation requests to the appropriate provider:
 * - Anthropic Claude Opus 4.5 for natural writing (connection notes, emails, comments)
 * - OpenAI GPT-5.1 for reasoning-heavy tasks (classification, analysis)
 * 
 * Claude Opus 4.5 Best Practices (from Anthropic docs):
 * 1. Be explicit with instructions - clearly specify desired output
 * 2. Provide context - explain the purpose and background
 * 3. Use structured prompts for complex tasks
 * 4. Set effort level based on task complexity
 * 
 * Falls back gracefully if Claude is unavailable.
 */

import { getContentGenerationConfig, type ModelConfig } from '../config/models.js';
import { getClaudeClient, type ClaudeEffort } from './anthropic.js';
import type { ResponsesAPIClient } from './responses.js';

// =============================================================================
// DATE CONTEXT
// =============================================================================

/**
 * Generate current date/time context for LLM prompts
 */
export function getDateContext(): string {
  const now = new Date();
  const options: Intl.DateTimeFormatOptions = {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    timeZoneName: 'short',
  };
  const formatted = now.toLocaleDateString('en-US', options);
  return `Current date/time: ${formatted}`;
}

// =============================================================================
// TYPES
// =============================================================================

export interface ContentGenerationResult {
  text: string;
  provider: 'openai' | 'anthropic';
  model: string;
  usage?: {
    inputTokens: number;
    outputTokens: number;
  };
}

export interface GenerateContentOptions {
  systemPrompt: string;
  userPrompt: string;
  maxTokens?: number;
  /** Claude Opus 4.5 effort level (low/medium/high) */
  effort?: ClaudeEffort;
  /** Force a specific provider (overrides config) */
  forceProvider?: 'openai' | 'anthropic';
}

// =============================================================================
// CONTENT GENERATOR
// =============================================================================

/**
 * Generate content using the configured provider
 * Defaults to Claude Opus 4.5 for natural writing
 * Automatically falls back to OpenAI if Claude is unavailable
 */
export async function generateContent(
  options: GenerateContentOptions,
  openaiClient: ResponsesAPIClient
): Promise<ContentGenerationResult> {
  const config = getContentGenerationConfig();
  const provider = options.forceProvider || config.provider;
  
  // Inject date context into system prompt
  const dateContext = getDateContext();
  const systemPromptWithDate = `${options.systemPrompt}\n\n${dateContext}`;
  
  // Try Claude Opus 4.5 first if configured
  if (provider === 'anthropic') {
    const claude = getClaudeClient();
    
    if (claude) {
      try {
        const effort = options.effort || config.effort || 'medium';
        console.log(`[ContentGen] Using Claude Opus 4.5 (effort: ${effort})`);
        
        const response = await claude.createMessage(
          systemPromptWithDate,
          options.userPrompt,
          {
            model: config.model,
            maxTokens: options.maxTokens || config.maxTokens,
            effort,
          }
        );
        
        return {
          text: response.text,
          provider: 'anthropic',
          model: config.model,
          usage: response.usage,
        };
      } catch (error) {
        console.warn('[ContentGen] Claude failed, falling back to OpenAI:', error);
        // Fall through to OpenAI
      }
    } else {
      console.log('[ContentGen] Claude not available (no API key), using OpenAI');
    }
  }
  
  // Use OpenAI (either as primary or fallback)
  console.log(`[ContentGen] Using OpenAI for content generation`);
  
  const input = [
    { type: 'message' as const, role: 'system' as const, content: systemPromptWithDate },
    { type: 'message' as const, role: 'user' as const, content: options.userPrompt },
  ];
  
  const response = await openaiClient.createResponse(input, [], {
    reasoningEffort: config.reasoningEffort || 'high',
  });
  
  return {
    text: response.outputText || '',
    provider: 'openai',
    model: config.model,
  };
}

/**
 * Generate a connection note
 */
export async function generateConnectionNote(
  systemPrompt: string,
  profileContext: string,
  openaiClient: ResponsesAPIClient
): Promise<string> {
  const result = await generateContent({
    systemPrompt,
    userPrompt: profileContext,
  }, openaiClient);
  
  console.log(`[ContentGen] Connection note generated by ${result.provider} (${result.model})`);
  return result.text;
}

/**
 * Generate a comment
 */
export async function generateComment(
  systemPrompt: string,
  postContext: string,
  openaiClient: ResponsesAPIClient
): Promise<string> {
  const result = await generateContent({
    systemPrompt,
    userPrompt: postContext,
  }, openaiClient);
  
  console.log(`[ContentGen] Comment generated by ${result.provider} (${result.model})`);
  return result.text;
}

/**
 * Generate an email draft
 */
export async function generateEmailDraft(
  systemPrompt: string,
  emailContext: string,
  openaiClient: ResponsesAPIClient
): Promise<{ subject?: string; body: string }> {
  const result = await generateContent({
    systemPrompt,
    userPrompt: emailContext,
    maxTokens: 2048, // Emails can be longer
  }, openaiClient);
  
  console.log(`[ContentGen] Email draft generated by ${result.provider} (${result.model})`);
  
  // Try to parse JSON response (subject + body)
  const text = result.text;
  const jsonMatch = text.match(/\{[\s\S]*\}/);
  if (jsonMatch) {
    try {
      const parsed = JSON.parse(jsonMatch[0]);
      if (parsed.subject && parsed.body) {
        return { subject: parsed.subject, body: parsed.body };
      }
    } catch {
      // Not valid JSON, use as body
    }
  }
  
  return { body: text };
}

/**
 * Classify content (always uses OpenAI for structured output)
 */
export async function classifyContent<T>(
  systemPrompt: string,
  contentToClassify: string,
  openaiClient: ResponsesAPIClient,
  parseResponse: (text: string) => T
): Promise<T> {
  // Inject date context
  const dateContext = getDateContext();
  const systemPromptWithDate = `${systemPrompt}\n\n${dateContext}`;
  
  // Classification always uses OpenAI (better at structured output)
  const input = [
    { type: 'message' as const, role: 'system' as const, content: systemPromptWithDate },
    { type: 'message' as const, role: 'user' as const, content: contentToClassify },
  ];
  
  const response = await openaiClient.createResponse(input, [], {
    reasoningEffort: 'low', // Classification doesn't need deep reasoning
  });
  
  return parseResponse(response.outputText || '');
}

