/**
 * Post Discovery - Find and surface relevant LinkedIn posts
 */

import type { WebClient } from '@slack/web-api';
import type { KnownBlock } from '@slack/bolt';
import { ResponsesAPIClient } from '../llm/responses.js';
import { 
  isUnipileConfigured,
  getActiveLinkedinAccountId,
  searchLinkedIn,
  getLocationIds,
} from '../tools/unipile-sdk.js';
import { isPostSeen, addSeenPost, getSeenPostsCount } from '../db/posts.js';
import type { DiscoveryConfig } from './config.js';
import { shouldThrottle, recordActivity } from './activity-tracker.js';
import { getContentGenerationConfig } from '../config/models.js';
import { generateContent } from '../llm/content-generator.js';
import { env } from '../config/env.js';
import { 
  POST_RELEVANCE_PROMPT,
  COMMENT_GENERATION_PROMPT,
  formatPostForRelevanceCheck,
  formatPostForComment,
} from '../prompts/index.js';
import { postToPostThread } from '../slack/post-thread.js';

// Static search terms for post discovery - targeting commercial insurance ecosystem
// Carriers, wholesalers, MGAs, and adjacent players
const STATIC_POST_SEARCH_TERMS = [
  // Core commercial insurance
  'commercial insurance',
  'commercial lines',
  'specialty insurance',
  'E&S insurance',
  'excess surplus',
  
  // Wholesalers & distribution
  'wholesale broker',
  'wholesale insurance',
  'surplus lines broker',
  'program administrator',
  
  // MGAs and carriers
  'MGA insurance',
  'managing general agent',
  'binding authority',
  'delegated underwriting',
  'program business',
  
  // Underwriting & operations
  'commercial underwriting',
  'submission clearance',
  'loss runs',
  'certificate of insurance',
  'subjectivities',
  
  // Industry trends
  'insurtech',
  'insurance automation',
  'hard market',
  'rate increases',
  
  // Specific lines
  'professional liability',
  'D&O insurance',
  'cyber insurance',
  'construction insurance',
  'transportation insurance',
  'property insurance commercial',
];

export interface DiscoveredPost {
  id: string;
  provider_id?: string;
  url?: string;
  author: { name: string; headline?: string };
  text: string;
  likes_count: number;
  comments_count: number;
}

function buildPostUrlFromId(id?: string): string | undefined {
  if (!id) return undefined;
  const idStr = String(id);
  if (idStr.includes('urn:li:activity:')) {
    return `https://www.linkedin.com/feed/update/${idStr}`;
  }
  return `https://www.linkedin.com/feed/update/urn:li:activity:${idStr}`;
}

function getPostUrl(p: any): string | undefined {
  const direct = p.url || p.webUrl || p.link;
  if (direct) return direct;

  const id = p.provider_id || p.id;
  return buildPostUrlFromId(id);
}

/**
 * Check if a post is relevant using AI
 */
export async function isPostRelevant(
  llm: ResponsesAPIClient, 
  post: { author: { name: string; headline?: string }; text: string }
): Promise<boolean> {
  try {
    const input = [
      { type: 'message' as const, role: 'system' as const, content: POST_RELEVANCE_PROMPT },
      { type: 'message' as const, role: 'user' as const, content: formatPostForRelevanceCheck(post) },
    ];

    const response = await llm.createResponse(input, []);
    const answer = (response.outputText || '').toLowerCase().trim();
    const isRelevant = answer.includes('yes');
    
    console.log(`[PostDiscovery] Relevance check for "${post.text.slice(0, 50)}...": ${isRelevant ? 'RELEVANT' : 'NOT RELEVANT'}`);
    return isRelevant;
  } catch (error) {
    console.error('[PostDiscovery] Failed to check relevance:', error);
    return true; // Default to including if we can't check
  }
}

/**
 * Generate a comment using Claude Opus 4.5 (effort: high)
 * 
 * Uses Claude for natural, human-like writing
 * Falls back to OpenAI if Claude unavailable
 */
export async function generateComment(
  llm: ResponsesAPIClient, // Used for fallback
  post: { author: { name: string }; text: string }
): Promise<string> {
  try {
    console.log(`[PostDiscovery] Generating comment for post by ${post.author.name} with Claude Opus 4.5...`);
    
    const result = await generateContent({
      systemPrompt: COMMENT_GENERATION_PROMPT,
      userPrompt: formatPostForComment(post),
      maxTokens: 512, // Comments are short
      effort: 'high', // High effort for quality writing
    }, llm);
    
    console.log(`[PostDiscovery] Comment generated by ${result.provider} (${result.model})`);
    console.log(`[PostDiscovery] Generated comment: "${result.text?.slice(0, 50)}..."`);
    return result.text || '';
  } catch (error) {
    console.error('[PostDiscovery] Failed to generate comment:', error);
    return '';
  }
}

/**
 * Discover relevant posts
 */
export async function discoverPosts(
  llm: ResponsesAPIClient,
  config: DiscoveryConfig
): Promise<DiscoveredPost[]> {
  // Check throttling
  const throttleCheck = shouldThrottle();
  if (throttleCheck.throttle) {
    console.log(`[PostDiscovery] Throttling: ${throttleCheck.reason}`);
    return [];
  }

  console.log('[PostDiscovery] Searching for posts...');

  // Use static search terms for consistency
  const searchTerms = STATIC_POST_SEARCH_TERMS;

  let posts: DiscoveredPost[] = [];

  if (isUnipileConfigured()) {
    // Search past_week by default for better coverage
    for (const keyword of searchTerms) {
      try {
        recordActivity('search');
        const results = await searchLinkedIn({
          category: 'posts',
          keywords: keyword,
          limit: 10, // More posts per search
          date_posted: 'past_week',
        });
        console.log(`[PostDiscovery] "${keyword}" returned ${results.items?.length || 0} posts`);
        posts.push(...results.items.map((p: any) => ({
          id: p.id,
          provider_id: p.provider_id,
          url: getPostUrl(p),
          author: p.author || { name: 'Unknown' },
          text: p.text || '',
          likes_count: p.likes_count || 0,
          comments_count: p.comments_count || 0,
        })));
      } catch (error) {
        console.error(`[PostDiscovery] Search failed for "${keyword}":`, error);
      }
    }
    console.log(`[PostDiscovery] Total posts found: ${posts.length}`);
  } else {
    posts = getMockPosts();
  }

  // Filter: dedupe, engagement threshold
  let candidates = posts
    .filter(p => !isPostSeen(p.provider_id || p.id))
    .filter(p => (p.likes_count + p.comments_count) >= config.posts.minEngagement);

  console.log(`[PostDiscovery] ${candidates.length} posts passed basic filters`);

  // Fallback: if none pass engagement, take top by engagement anyway
  if (candidates.length === 0 && posts.length > 0) {
    candidates = posts
      .filter(p => !isPostSeen(p.provider_id || p.id))
      .sort((a, b) => (b.likes_count + b.comments_count) - (a.likes_count + a.comments_count))
      .slice(0, config.posts.maxPostsPerRun);
    console.log('[PostDiscovery] Using fallback by engagement since none met threshold');
  }

  // AI relevance scoring
  const relevantPosts: DiscoveredPost[] = [];
  for (const post of candidates.slice(0, 10)) {
    const isRelevant = await isPostRelevant(llm, post);
    if (isRelevant) {
      relevantPosts.push(post);
      if (relevantPosts.length >= config.posts.maxPostsPerRun) break;
    }
  }

  console.log(`[PostDiscovery] ${relevantPosts.length} posts passed AI relevance check`);

  // Mark as seen
  for (const post of relevantPosts) {
    addSeenPost(post.provider_id || post.id, post.provider_id || undefined);
  }

  return relevantPosts;
}

/**
 * Surface a post in Slack
 */
export async function surfacePost(
  slackClient: WebClient,
  llm: ResponsesAPIClient,
  post: DiscoveredPost,
  config: DiscoveryConfig
): Promise<void> {
  let draftComment = '';
  const postUrl = post.url || buildPostUrlFromId(post.provider_id || post.id);

  if (config.posts.autoGenerateComments) {
    draftComment = await generateComment(llm, post);
  }

  const baseBlocks: KnownBlock[] = [
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*${post.author.name}*${post.author.headline ? ` · ${post.author.headline}` : ''}

"${post.text.slice(0, 300)}${post.text.length > 300 ? '...' : ''}"`,
      },
    },
    {
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `${post.likes_count} likes · ${post.comments_count} comments${postUrl ? ` · <${postUrl}|View Post>` : ''}`,
        },
      ],
    },
  ];

  if (draftComment) {
    baseBlocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Draft comment:*
\`\`\`${draftComment}\`\`\``,
      },
    });
  }

  const blocks: KnownBlock[] = [
    ...baseBlocks,
    {
      type: 'actions',
      elements: [
        ...(postUrl
          ? [{
              type: 'button' as const,
              text: { type: 'plain_text' as const, text: 'View Post', emoji: false },
              url: postUrl,
              action_id: 'discovery_view_post',
            }]
          : []),
        {
          type: 'button',
          text: { type: 'plain_text', text: 'Like', emoji: false },
          action_id: 'discovery_like',
          value: JSON.stringify({
            postId: post.provider_id || post.id,
            postUrl: postUrl,
          }),
        },
        ...(draftComment
          ? [{
              type: 'button' as const,
              text: { type: 'plain_text' as const, text: 'Comment', emoji: false },
              style: 'primary' as const,
              action_id: 'discovery_comment_send',
              value: JSON.stringify({
                postId: post.provider_id || post.id,
                postUrl: postUrl,
                draftComment,
              }),
            }]
          : []),
        {
          type: 'button',
          text: { type: 'plain_text', text: 'Edit', emoji: false },
          action_id: 'discovery_comment_edit',
          value: JSON.stringify({
            postId: post.provider_id || post.id,
            postUrl: postUrl,
            draftComment,
          }),
        },
        {
          type: 'button',
          text: { type: 'plain_text', text: 'Skip', emoji: false },
          action_id: 'discovery_skip',
          value: JSON.stringify({
            postId: post.provider_id || post.id,
            postUrl: postUrl,
          }),
        },
      ],
    },
  ];

  await postToPostThread(slackClient, config.slack.channelId, {
    text: `Found a relevant post by ${post.author.name}`,
    blocks,
  });
}

/**
 * Get count of seen posts
 */
// Persistent count from DB
export { getSeenPostsCount } from '../db/posts.js';

// ============================================
// MOCK DATA
// ============================================

function getMockPosts(): DiscoveredPost[] {
  return [
    {
      id: `mock-post-${Date.now()}-1`,
      url: 'https://linkedin.com/posts/mock-1',
      author: { name: 'Sarah Chen', headline: 'VP of Underwriting at Specialty Risk' },
      text: 'The E&S market continues to evolve. We just processed our 10,000th submission this quarter using our new AI-assisted workflow. The efficiency gains are remarkable.',
      likes_count: 156,
      comments_count: 34,
    },
    {
      id: `mock-post-${Date.now()}-2`,
      url: 'https://linkedin.com/posts/mock-2',
      author: { name: 'Mike Rodriguez', headline: 'CEO at QuickBind MGA' },
      text: 'Hot take: The future of MGAs is not just about distribution - it\'s about data. The MGAs that win will be the ones that can underwrite risks others can\'t even price.',
      likes_count: 234,
      comments_count: 67,
    },
  ];
}

