/**
 * Post Discovery - Find and surface relevant LinkedIn posts
 */

import type { WebClient } from '@slack/web-api';
import type { KnownBlock } from '@slack/bolt';
import { ResponsesAPIClient } from '../llm/responses.js';
import { 
  isUnipileConfigured,
  getActiveLinkedinAccountId,
  searchLinkedIn,
  getLocationIds,
} from '../tools/unipile-sdk.js';
import type { DiscoveryConfig } from './config.js';
import { shouldThrottle, recordActivity } from './activity-tracker.js';
import { getContentGenerationConfig } from '../config/models.js';
import { generateContent } from '../llm/content-generator.js';
import { env } from '../config/env.js';
import {
  POST_SEARCH_TERMS_PROMPT,
  POST_RELEVANCE_PROMPT,
  COMMENT_GENERATION_PROMPT,
  formatPostForRelevanceCheck,
  formatPostForComment,
} from '../prompts/index.js';

// Track seen posts to avoid duplicates
const seenPosts = new Set<string>();

export interface DiscoveredPost {
  id: string;
  provider_id?: string;
  url?: string;
  author: { name: string; headline?: string };
  text: string;
  likes_count: number;
  comments_count: number;
}

/**
 * Generate search terms using AI
 */
export async function generatePostSearchTerms(llm: ResponsesAPIClient): Promise<string[]> {
  try {
    const input = [
      { type: 'message' as const, role: 'system' as const, content: POST_SEARCH_TERMS_PROMPT },
      { type: 'message' as const, role: 'user' as const, content: 'Generate 3 diverse search terms.' },
    ];

    const response = await llm.createResponse(input, []);
    const terms = (response.outputText || '')
      .split('\n')
      .map(t => t.trim())
      .filter(t => t.length > 0)
      .slice(0, 3);
    
    console.log(`[PostDiscovery] AI generated search terms: ${terms.join(', ')}`);
    return terms.length > 0 ? terms : ['MGA insurance technology', 'wholesale insurance automation', 'E&S underwriting'];
  } catch (error) {
    console.error('[PostDiscovery] Failed to generate search terms:', error);
    return ['MGA insurance technology', 'wholesale insurance automation', 'E&S underwriting'];
  }
}

/**
 * Check if a post is relevant using AI
 */
export async function isPostRelevant(
  llm: ResponsesAPIClient, 
  post: { author: { name: string; headline?: string }; text: string }
): Promise<boolean> {
  try {
    const input = [
      { type: 'message' as const, role: 'system' as const, content: POST_RELEVANCE_PROMPT },
      { type: 'message' as const, role: 'user' as const, content: formatPostForRelevanceCheck(post) },
    ];

    const response = await llm.createResponse(input, []);
    const answer = (response.outputText || '').toLowerCase().trim();
    const isRelevant = answer.includes('yes');
    
    console.log(`[PostDiscovery] Relevance check for "${post.text.slice(0, 50)}...": ${isRelevant ? 'RELEVANT' : 'NOT RELEVANT'}`);
    return isRelevant;
  } catch (error) {
    console.error('[PostDiscovery] Failed to check relevance:', error);
    return true; // Default to including if we can't check
  }
}

/**
 * Generate a comment using Claude Opus 4.5 (effort: high)
 * 
 * Uses Claude for natural, human-like writing
 * Falls back to OpenAI if Claude unavailable
 */
export async function generateComment(
  llm: ResponsesAPIClient, // Used for fallback
  post: { author: { name: string }; text: string }
): Promise<string> {
  try {
    console.log(`[PostDiscovery] Generating comment for post by ${post.author.name} with Claude Opus 4.5...`);
    
    const result = await generateContent({
      systemPrompt: COMMENT_GENERATION_PROMPT,
      userPrompt: formatPostForComment(post),
      maxTokens: 512, // Comments are short
      effort: 'high', // High effort for quality writing
    }, llm);
    
    console.log(`[PostDiscovery] Comment generated by ${result.provider} (${result.model})`);
    console.log(`[PostDiscovery] Generated comment: "${result.text?.slice(0, 50)}..."`);
    return result.text || '';
  } catch (error) {
    console.error('[PostDiscovery] Failed to generate comment:', error);
    return '';
  }
}

/**
 * Discover relevant posts
 */
export async function discoverPosts(
  llm: ResponsesAPIClient,
  config: DiscoveryConfig
): Promise<DiscoveredPost[]> {
  // Check throttling
  const throttleCheck = shouldThrottle();
  if (throttleCheck.throttle) {
    console.log(`[PostDiscovery] Throttling: ${throttleCheck.reason}`);
    return [];
  }

  console.log('[PostDiscovery] Searching for posts...');

  // Generate search terms using AI
  const searchTerms = await generatePostSearchTerms(llm);

  let posts: DiscoveredPost[] = [];

  if (isUnipileConfigured()) {
    for (const keyword of searchTerms) {
      try {
        recordActivity('search');
        const results = await searchLinkedIn({
          category: 'posts',
          keywords: keyword,
          limit: 5,
          date_posted: 'past_day',
        });
        posts.push(...results.items.map((p: any) => ({
          id: p.id,
          provider_id: p.provider_id,
          url: p.url,
          author: p.author || { name: 'Unknown' },
          text: p.text || '',
          likes_count: p.likes_count || 0,
          comments_count: p.comments_count || 0,
        })));
      } catch (error) {
        console.error(`[PostDiscovery] Search failed for "${keyword}":`, error);
      }
    }
  } else {
    posts = getMockPosts();
  }

  // Filter: dedupe, engagement threshold
  const basicFiltered = posts
    .filter(p => !seenPosts.has(p.provider_id || p.id))
    .filter(p => (p.likes_count + p.comments_count) >= config.posts.minEngagement);

  console.log(`[PostDiscovery] ${basicFiltered.length} posts passed basic filters`);

  // AI relevance scoring
  const relevantPosts: DiscoveredPost[] = [];
  for (const post of basicFiltered.slice(0, 10)) {
    const isRelevant = await isPostRelevant(llm, post);
    if (isRelevant) {
      relevantPosts.push(post);
      if (relevantPosts.length >= config.posts.maxPostsPerRun) break;
    }
  }

  console.log(`[PostDiscovery] ${relevantPosts.length} posts passed AI relevance check`);

  // Mark as seen
  for (const post of relevantPosts) {
    seenPosts.add(post.provider_id || post.id);
  }

  return relevantPosts;
}

/**
 * Surface a post in Slack
 */
export async function surfacePost(
  slackClient: WebClient,
  llm: ResponsesAPIClient,
  post: DiscoveredPost,
  config: DiscoveryConfig
): Promise<void> {
  let draftComment = '';

  if (config.posts.autoGenerateComments) {
    draftComment = await generateComment(llm, post);
  }

  const baseBlocks: KnownBlock[] = [
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*${post.author.name}*${post.author.headline ? ` · ${post.author.headline}` : ''}

"${post.text.slice(0, 300)}${post.text.length > 300 ? '...' : ''}"`,
      },
    },
    {
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `${post.likes_count} likes · ${post.comments_count} comments${post.url ? ` · <${post.url}|View Post>` : ''}`,
        },
      ],
    },
  ];

  if (draftComment) {
    baseBlocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: `*Draft comment:*
\`\`\`${draftComment}\`\`\``,
      },
    });
  }

  const blocks: KnownBlock[] = [
    ...baseBlocks,
    {
      type: 'actions',
      elements: [
        {
          type: 'button',
          text: { type: 'plain_text', text: 'Comment', emoji: false },
          style: 'primary',
          action_id: 'discovery_comment',
          value: JSON.stringify({
            postId: post.provider_id || post.id,
            postUrl: post.url,
            draftComment,
          }),
        },
        {
          type: 'button',
          text: { type: 'plain_text', text: 'Like', emoji: false },
          action_id: 'discovery_like',
          value: JSON.stringify({
            postId: post.provider_id || post.id,
            postUrl: post.url,
          }),
        },
        {
          type: 'button',
          text: { type: 'plain_text', text: 'Skip', emoji: false },
          action_id: 'discovery_skip',
          value: JSON.stringify({
            postId: post.provider_id || post.id,
            postUrl: post.url,
          }),
        },
      ],
    },
  ];

  await slackClient.chat.postMessage({
    channel: config.slack.channelId,
    text: `Found a relevant post by ${post.author.name}`,
    blocks,
  });
}

/**
 * Get count of seen posts
 */
export function getSeenPostsCount(): number {
  return seenPosts.size;
}

// ============================================
// MOCK DATA
// ============================================

function getMockPosts(): DiscoveredPost[] {
  return [
    {
      id: `mock-post-${Date.now()}-1`,
      url: 'https://linkedin.com/posts/mock-1',
      author: { name: 'Sarah Chen', headline: 'VP of Underwriting at Specialty Risk' },
      text: 'The E&S market continues to evolve. We just processed our 10,000th submission this quarter using our new AI-assisted workflow. The efficiency gains are remarkable.',
      likes_count: 156,
      comments_count: 34,
    },
    {
      id: `mock-post-${Date.now()}-2`,
      url: 'https://linkedin.com/posts/mock-2',
      author: { name: 'Mike Rodriguez', headline: 'CEO at QuickBind MGA' },
      text: 'Hot take: The future of MGAs is not just about distribution - it\'s about data. The MGAs that win will be the ones that can underwrite risks others can\'t even price.',
      likes_count: 234,
      comments_count: 67,
    },
  ];
}

